package hotstuffpb

import "github.com/relab/hotstuff"

type ProposeMsg interface {
	ID() hotstuff.ID
	GetBlock() *Block
	GetAggQC() *AggQC
}

type BlockMsg interface {
	GetParent() []byte
	GetQC() *QuorumCert
	GetView() uint64
	GetCommand() []byte
	GetProposer() uint32
}

type AggregateQCMsg interface {
	GetQCs() map[uint32]*QuorumCert
	GetSig() *ThresholdSignature
	GetView() uint64
}

func (x *Proposal) ID() hotstuff.ID {
	return hotstuff.ID(x.GetBlock().GetProposer())
}

func NewProposeMsg(id hotstuff.ID, block BlockMsg, aggregateQC AggregateQCMsg) ProposeMsg {
	return &Proposal{
		Block: &Block{
			Parent:   block.GetParent(),
			QC:       block.GetQC(),
			View:     block.GetView(),
			Command:  block.GetCommand(),
			Proposer: block.GetProposer(),
		},
		AggQC: &AggQC{
			QCs:  aggregateQC.GetQCs(),
			Sig:  aggregateQC.GetSig(),
			View: aggregateQC.GetView(),
		},
	}
}

// TODO(meling): Add microbenchmark to compare using interface vs direct pb struct vs current translation layer (I think this was the other approach mentioned by Raytar).
// TODO(meling): These interfaces can easily be generated by the protobuf (or gorums) compiler.
